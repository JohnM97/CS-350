# CS-350
Project Reflection

Over the semester I carried a fresh Raspberry Pi through every stage of embedded‐systems development: from headless SSH setup and basic GPIO-driven LEDs and buttons, to I²C sensor integration, finite-state-machine design, threading, and finally a fully automated thermostat. By gradually building reusable hardware-abstraction modules and clean control logic, I ended up with a device that reliably reads temperature and humidity, displays them on a 16×2 LCD, and toggles a heating element based on user-defined thresholds.

Modularity was my greatest strength. Early on I separated pin definitions, sensor drivers, state-machine logic, and user interfaces into distinct files, which made it trivial to repurpose components for later labs. Threading allowed sensor polling without blocking, and using the statemachine library kept transitions clear and declarative. Thorough inline comments and a step-by-step README meant anyone could reproduce my setup—from OS install and network configuration to Python virtual-environment management.

In hindsight, I should have introduced automated testing much sooner. Relying exclusively on physical hardware slowed iterations and made it easy to overlook edge cases. Moving forward I’ll mock GPIO and sensor inputs with unittest.mock or pytest fixtures so I can validate logic on my laptop. I also learned that centralizing all configuration (pin mappings, I²C addresses, temperature thresholds) in a single file from day one saves countless refactoring headaches when requirements shift.

Throughout the course I leaned heavily on the official Raspberry Pi documentation, the gpiozero API reference, and community Q&A on Raspberry Pi Stack Exchange. I’m now comfortable with headless Linux management over SSH and automating deployments via scripts—a skill set that translates directly to IoT, robotics, and cloud environments with background workers. Keeping code small, focused, and well-documented ensures that this project remains readable, maintainable, and adaptable for whatever I build next.
